<style>
@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap');
body {
    font-family: 'Noto Sans SC', sans-serif;
}
</style>
<h1 id="autoview-工程分析与迁移可行性总结">AutoView
工程分析与迁移可行性总结</h1>
<h2 id="任务背景">1. 任务背景</h2>
<p>用户希望分析 <code>/Users/wurongquan/autoview/</code> 工程的主要
Pipeline，并评估是否可以将其中的 “LLM 到 JSON Scheme” 步骤嫁接到当前
React Native 工程 (<code>card-style-genui-rn</code>)，以实现大模型驱动的
UI 渲染。</p>
<h2 id="autoview-工程分析">2. AutoView 工程分析</h2>
<p>经过对 <code>autoview</code> 源码的深入分析，我们得出以下结论：</p>
<h3 id="核心逻辑">2.1 核心逻辑</h3>
<p><code>autoview</code> 的核心并不是生成 JSON
Scheme，而是<strong>直接生成代码</strong>。 * <strong>输入</strong>:
用户查询 (Context) + 预定义的业务数据 Schema。 * <strong>处理</strong>:
大模型 (LLM) 接收 Schema 定义和用户需求，生成对应的 <strong>React
组件代码 (.tsx)</strong>。 * <strong>输出</strong>: 编译后的 JavaScript
代码，在 Web 端渲染。</p>
<h3 id="流程图-pipeline">2.2 流程图 (Pipeline)</h3>
<pre class="mermaid"><code>graph TD
    User[&quot;用户&quot;] --&gt;|&quot;消息&quot;| ChatAgent[&quot;AutoViewChatAgent&quot;]
    ChatAgent --&gt;|&quot;上下文&quot;| AutoViewAgent[&quot;AutoViewAgent&quot;]
    
    subgraph &quot;AutoView 核心流程&quot;
        InputSchema[&quot;输入 Schema&quot;] --&gt;|&quot;转换&quot;| Metadata[&quot;编译器元数据&quot;]
        Metadata --&gt; AutoViewAgent
        
        AutoViewAgent --&gt;|&quot;Schema + 上下文&quot;| CodeGen[&quot;代码生成 Agent&quot;]
        
        CodeGen --&gt;|&quot;Prompt (模版 + 上下文)&quot;| LLM_Code[&quot;大模型 (生成代码)&quot;]
        LLM_Code --&gt;|&quot;React 组件代码 (TSX)&quot;| Compiler[&quot;AutoViewCompiler&quot;]
        Compiler --&gt;|&quot;编译&quot;| CompiledCode[&quot;编译后的 JS&quot;]
    end
    
    CompiledCode --&gt;|&quot;结果&quot;| ChatAgent</code></pre>
<h2 id="迁移可行性分析">3. 迁移可行性分析</h2>
<h3 id="误区澄清">3.1 误区澄清</h3>
<p>用户提到的 “从 LLM 到 JSON Scheme” 步骤在 <code>autoview</code>
中并不存在（或者是对 “Schema 输入” 的误解）。<code>autoview</code> 是
“Schema 输入 -&gt; LLM -&gt; 代码输出”。</p>
<h3 id="直接嫁接-不可行">3.2 直接嫁接 (不可行)</h3>
<ul>
<li><strong>平台不兼容</strong>: <code>autoview</code> 生成的是 Web 端
React 代码 (HTML 标签, Tailwind CSS)，无法直接在 React Native
中运行。</li>
<li><strong>运行时限制</strong>: React Native (尤其是 Hermes 引擎)
不支持动态编译和执行代码 (如 <code>eval</code>)，因此无法直接运行 LLM
生成的代码。</li>
</ul>
<h3 id="逻辑复用-非常可行">3.3 逻辑复用 (非常可行)</h3>
<p>虽然代码不能直接用，但 <strong>Prompt Engineering 的思想</strong>
可以完美复用。我们可以用“生成 DSL 数据”来替代“生成代码”。</p>
<p><strong>推荐方案：</strong> 1. <strong>保留现有渲染器</strong>:
继续使用当前工程中成熟的 <code>DslParser</code> 和
<code>DslRenderer</code>。 2. <strong>借鉴 AutoView 思想</strong>: *
<strong>Schema 定义</strong>: 将当前的 UI DSL (Column, Row, WeatherCard
等) 定义为 Schema。 * <strong>Prompt 构建</strong>: 参考
<code>autoview</code> 的 Prompt，将 DSL Schema 和用户查询传给大模型。 *
<strong>指令修改</strong>: 指示大模型输出 <strong>JSON 格式的 DSL
数据</strong>，而不是 React 代码。</p>
<h2 id="新方案架构图">4. 新方案架构图</h2>
<p>这是结合了 <code>autoview</code>
的大模型驱动思想与当前工程渲染能力的最佳实践方案：</p>
<pre class="mermaid"><code>graph TD
    User[&quot;用户&quot;] --&gt;|&quot;用户查询&quot;| NewAgent[&quot;新 LLM Agent&quot;]
    
    subgraph &quot;借鉴 AutoView 逻辑&quot;
        DSL_Schema[&quot;DSL 定义 Schema&quot;] --&gt; NewAgent
        NewAgent --&gt;|&quot;Prompt (Schema + 查询)&quot;| LLM[&quot;大模型&quot;]
        LLM --&gt;|&quot;生成&quot;| JSON_DSL[&quot;JSON DSL 数据&quot;]
    end
    
    JSON_DSL --&gt;|&quot;解析&quot;| DslParser[&quot;现有 DslParser&quot;]
    DslParser --&gt;|&quot;渲染&quot;| DslRenderer[&quot;现有 DslRenderer&quot;]
    DslRenderer --&gt;|&quot;展示&quot;| AppUI[&quot;React Native UI&quot;]</code></pre>
<h2 id="结论">5. 结论</h2>
<ul>
<li><strong>AutoView 的代码</strong>：不适合直接迁移到 RN。</li>
<li><strong>AutoView 的逻辑</strong>：非常适合。通过让 LLM 生成 JSON
DSL，可以实现灵活的“大模型驱动
UI”，同时规避了移动端动态执行代码的风险。</li>
</ul>
